What we got:

Your program is a process (or coroutine) which contains an implicit "viewable"
thing that might animate with time. What can your process do.

- Wait for an event, possibly with a timeout.
- Sleep for a fixed amount of time, possibly forever.
- Look at a view.
- Modify your own implicit "viewable".
- Create new ports.
- Artificially trigger a signal on a port.
- Execute a fire-and-forget IO action.
- Execute an IO action and wait for the results "asynchronously".
- Fork another process. This gives you a view and a checkpoint event.
- Terminate.

When the original process terminates the program is over. While it's running
your driver should be able to look at the original processes "view" to get
real time feedback on what's happening. You can interact with the simulation
by writing to external ports which processes may be waiting on.

Events are selections and filters of occurrences. Occurrences are generated by
- writing to ports
- by checkpoints
- or by the termination of processes.

Events can also see views at the time of an occurrence. The snapshotted info
can be incorporated into the event payload, or can be used to filter.

Views are just functions of the current processes viewable values. The
recursion here makes sense because some processes have constant values as
their viewable, and some are generated with an isolated simulation (generators).

